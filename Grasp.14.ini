;;;;;  
;;;;; Configuration file fo the Grasp VR program.
;;;;; This version is configured to use the new aiming paradigm
;;;;;  in which there is an inflating balloon to discourage cheating.
;;;;;

[GraspGLObjects]

vToolSize = 2.0
vToolLocation = < 0.0 0.0 -500.0 >
vkToolSize = 1.0
hmdTransparency = 0.5

targetBallRadius = 100.0
;;; targetBallSpacing =
targetBalls = 3
targetBarRadius = 20.0
;;; targetBarSpacing = 
targetBars = 10
useBars = true
fingerBallRadius = 10.0
fingerLength = 100.0


;;; How much the laser diffuses when off alignment
laserDiffusionConstant = 0.0
;;; The following sets the zone within which the laser
;;; is perfectly focused.  But the parameter is misnamed.
;;; Set it to 1.0 if you want no deadzone. Set it to -1.0
;;; if you want an infinite deadzone (always focused).
laserDiffusionDeadzone = 1.0
;;; The system places the dot representing the laser pointer
;;; at a fixed distance from the hand of the subject.
laserDistance = 1600.0

headArrowLocation = < 0.0 0.0 -600.0 >
headArrowRadius = 250.0
handArrowRadius = 60.0

[GraspVR]
	
IPD = 50.0

;;; The following used to determine whether the hand was raised or not.
;;; But the algorithm was changed to that of checking if the hand is
;;; in front of the viewer and within the circular cross section of the tunnel.
;;; So I do not believe that this parameter is still used.
;;; Parameters for the new algorithm are hard coded.
armRaisedThreshold = 0.9

;;; Threshold to determine when gaze angle is aligned with tunnel.
straightAheadThreshold = 0.995

;;; The following parameter determines the threshold at which the alignment  
;;; of the hand in pitch and yaw is considered to be good enough. 
;;; Use 0.96 to have the original size of the cyan target ball.
;;; I suggest 0.97 for the new method with the balloon mask.
pointingThreshold = 0.97

;;; Originally, the target disk was always cyan.
;;; In the new version, we set it initially to be grey, until the 
;;; laser enters the target region.
showGoodAiming = true

;;; Another way to work  is to require that the hand point
;;; near the center of the end of the tunnel, not just aligned with
;;; its axis. This flags turns this feature off and on.
useLaserEndpoint = true

;;; To avoid distraction by the laser, one can extinguish it
;;; once the hand has been properly aligned for at least an instant.
extinguishLaser = true

;;; Or one can skip the laser pointer altogether.
noLasers = false

;;; Finally, one can try to foil attempts to point at visual targets
;;; by inflating a ballon in front of the subject when he or she
;;; points toward the tunnel walls. 
;;; 
;;; NB: One should activate extinguishLaser above to have the best effect.
;;;
balloonMask = true
balloonInflationRate = 20.0

;;; The requirements on head pitch and yaw depend on how the
;;; chest markers sit on the torso of the subject.
;;; These paramerters allow one to virtually shift the structures in depth
;;; in order to adjust to achieve a comfortable pose of the head with
;;; level gaze when looking at the straight-ahead target.
viewpointOffset = 100

;;; The chest offset is frequently used to adjust for each subject on ground.
chestOffset = 100

[GraspTrackers]

;;; Tracking priorities.
;;; For each structure, the tracker uses data first from one tracker,
;;; if available, and then from the other.
;;; 1 for Coda 1 only, 2 for Coda 2 only 
;;; 21 for cascade (first 2 then 1)
;;; 12 for cascade (first 1 then 2)
hmdCodaCascade = 2
handCodaCascade = 21
chestCodaCascade = 21

;;; Determines whether the pose tracker for each cascade object is 
;;; realigned to the pose of the tracker above it in the hierarchy
;;; whenever both are visible. (true or false)
cascadeRealignment = false

;;; These are the filters for the CODA based pose trackers.
;;; The higher the value, the greater the low-pass filtering.
;;; A high value will supress jitter but will introduce lag.
;;; Note that the filtering of the HMD is further affected by 
;;; the parameters of the Kalman filter below.
hmdFilterConstant = 2.0
handFilterConstant = 2.0
chestFilterConstant = 10.0

;;; HMD Adaptive Kalman Filter
;;; When the optical markers have not been seen for awhile, we want
;;; to converge quickly to the optical data, rather than drifting
;;; slowly toward it. On the other hand, when the optical data is 
;;; readily available, we can filter it to reduce noise, as it is only
;;; used to correct for slow drift of the inertial estimate. 
;;; Here we define 2 weighting factors and a time constant for how
;;; the system shifts between them.  If you want to negate this 
;;; behavior, set both weighting factors to the same value (e.g. 10.0).
occlusionWeightingTimeConstant = 0.01
precaptureInertialWeighting = 1.0;
postcaptureInertialWeighting = 100.0;

